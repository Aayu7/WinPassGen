/*
 *  WinPassGen - Ultra-Secure Offline Password Generator for Windows.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 *  SECURITY:
 *    - Entropy is collected from the system CSPRNG, mouse movements, 64 bit ultra-high precision timer, etc.
 *    - Entropy is mixed into a 192-byte pool with WHIRLPOOL.
 *    - Passwords are generated by repeatedly obtaining a byte from the pool, checking if it is less than
 *      the character set size, and if so, using that index into the character set, and if not, discarding
 *      the byte and reading another.
 */

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <windowsx.h>
#include <wincrypt.h>
#include <tchar.h>
#include <intrin.h>
#include <psapi.h>
#include <queue>
#include "resource.h"

extern "C" {
    #include "nessie.h"
}
#pragma intrinsic(__rdtsc)

#define POOL_SIZE (3 * 64) // MUST be a multiple of the hash size (64 bytes)

HINSTANCE hInst;
HWND hDialog;

NESSIEstruct newEntropy;
HANDLE mouseRandMutex;
unsigned int pos = 0;
unsigned char* pool;
unsigned int mixCount = 0;
bool frozen;

// Applies the mixing function to the pool.
void Mix()
{
    unsigned char poolHash[64];
    NESSIEstruct wp;
    for(int i = 0; i < POOL_SIZE; i+= 64)
    {
        NESSIEinit(&wp);
        NESSIEadd(pool, POOL_SIZE * 8, &wp);
        NESSIEfinalize(&wp, poolHash);

        for(int j = 0; j < 64; j++)
            pool[(i+j) % POOL_SIZE] ^= poolHash[j];
    }
    mixCount++;
}

// Inserts entropy into the pool and mixes the pool.
void Mixin(void* data, unsigned int size)
{
    for(int i = 0; i < size; i++)
    {
        pool[pos] += ((unsigned char*)data)[i];
        pos = (pos + 1) % POOL_SIZE;
        if(pos == 0) //Mix the pool if we've reached the end
            Mix();
    }
    Mix();
}

inline unsigned char getMinimalBitMask(unsigned char toRepresent)
{
    if(toRepresent <= 0x01)
        return 0x01;
    else if(toRepresent <= 0x03)
        return 0x03;
    else if(toRepresent <= 0x07)
        return 0x07;
    else if(toRepresent <= 0x0F)
        return 0x0F;
    else if(toRepresent <= 0x1F)
        return 0x1F;
    else if(toRepresent <= 0x3F)
        return 0x3F;
    else if(toRepresent <= 0x7F)
        return 0x7F;
    else
        return 0xFF;
}

// Mixes randomness into the pool then converts the state of the pool to a password.
// pass - out - buffer to store the password.
// charSet - in - null-terminated string of acceptable characters.
void PoolToPass(TCHAR pass[65], LPTSTR charSet)
{
    //Mix in known-good randomness per-password just to be safe.
    HCRYPTPROV hCryptCtx = NULL;
    CryptAcquireContext(&hCryptCtx, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    unsigned char rand[32];
    CryptGenRandom(hCryptCtx, 32, rand);
    CryptReleaseContext(hCryptCtx, 0);
    __int64 time = __rdtsc();
    Mixin((void*)&time, sizeof(__int64));
    Mixin((void*)&rand, 64);

    // Save some of the state so we can mix it in later so the state can't be
    // reconstructed from the passwords without breaking the hash function.
    memcpy(rand, pool, 32);
    Mix();

    unsigned int charSetLen = _tcslen(charSet);
    if(charSetLen > 255)
        throw 1;
    unsigned char mask = getMinimalBitMask((unsigned char)(charSetLen - 1));
    int passIdx = 0;
    int poolIdx = 0;
    while(passIdx < 64)
    {
        // Never use any of the last 16-bytes of the pool as a
        // precaution against recovery of the pool state from the passwords.
        if(poolIdx >= POOL_SIZE - 16)
        {
            Mix();
            poolIdx = 0;
        }
        unsigned char c = pool[poolIdx++];
        c = c & mask;

        if(c < charSetLen)
        {
            pass[passIdx] = charSet[c];
            passIdx++;
        }
    }
    pass[64] = 0;

    // Mix in some data from the previous state so an adversary with a lot of
    // passwords can't reconstruct the state w/o breaking the hash function.
    Mixin((void*)&rand, 64);
}

// Updates the GUI with new passwords.
void UpdatePasswords()
{
    TCHAR pass[65];

    PoolToPass(pass, TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~`!@#$%^&*()-_=+{[}]|\\:;\"'<,>.?/"));
    SetDlgItemText(hDialog, IDC_ASCII, (LPCTSTR)&pass);

    PoolToPass(pass, TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"));
    SetDlgItemText(hDialog, IDC_ALPHANUM, (LPCTSTR)&pass);

    PoolToPass(pass, TEXT("0123456789ABCDEF"));
    SetDlgItemText(hDialog, IDC_HEX, (LPCTSTR)&pass);
}

// Background thread entrypoint.
// This thread's purpose is to periodically mix in the entropy provided by the UI thread,
// mix in entropy from the Windows CSPRNG, and rapidly change the passwords displayed on the UI.
DWORD Mixer(LPVOID lpdwThreadParam)
{
    HCRYPTPROV hCryptCtx = NULL;
    CryptAcquireContext(&hCryptCtx, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    while(true)
    {
        if(WaitForSingleObject(mouseRandMutex, INFINITE) == WAIT_OBJECT_0)
        {
            unsigned char hash[64];
            NESSIEfinalize(&newEntropy, hash);
            NESSIEinit(&newEntropy);
            Mixin(hash, 64);
        }
        ReleaseMutex(mouseRandMutex);

        unsigned char rand[32];
        CryptGenRandom(hCryptCtx, 32, rand);
        __int64 time = __rdtsc();
        Mixin((void*)&time, sizeof(__int64));
        Mixin((void*)&rand, 32);

        PROCESS_MEMORY_COUNTERS_EX memInfo;
        HANDLE currentProcess = GetCurrentProcess();
        GetProcessMemoryInfo(currentProcess, (PROCESS_MEMORY_COUNTERS*)&memInfo, sizeof(PROCESS_MEMORY_COUNTERS_EX));
        Mixin((void*)&memInfo, sizeof(PROCESS_MEMORY_COUNTERS_EX));

        if(!frozen)
        {
            UpdatePasswords();
        }
        SetDlgItemInt(hDialog, IDC_POOLMIX, mixCount, FALSE);
        Sleep(20);
    }
}

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Add all messages to the entropy pool.
    if(WaitForSingleObject(mouseRandMutex, INFINITE) == WAIT_OBJECT_0)
    {
        unsigned __int64 time = __rdtsc();
        NESSIEadd((unsigned char*)&time, sizeof(unsigned __int64) * 8, &newEntropy);
        NESSIEadd((unsigned char*)&uMsg, sizeof(UINT) * 8, &newEntropy);
        NESSIEadd((unsigned char*)&wParam, sizeof(WPARAM) * 8, &newEntropy);
        NESSIEadd((unsigned char*)&lParam, sizeof(LPARAM) * 8, &newEntropy);
    }
    ReleaseMutex(mouseRandMutex);

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            hDialog = hwndDlg;

            HFONT fixedWidth = CreateFont(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, TEXT("Courier"));
            SendMessage(GetDlgItem(hwndDlg, IDC_ASCII), WM_SETFONT, (WPARAM)fixedWidth , TRUE);
            SendMessage(GetDlgItem(hwndDlg, IDC_ALPHANUM), WM_SETFONT, (WPARAM)fixedWidth , TRUE);
            SendMessage(GetDlgItem(hwndDlg, IDC_HEX), WM_SETFONT, (WPARAM)fixedWidth , TRUE);

            HICON hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1));
            SendMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
            return TRUE;
        }
        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return TRUE;

        case WM_MOUSEMOVE:
            if(WaitForSingleObject(mouseRandMutex, INFINITE) == WAIT_OBJECT_0)
            {
                //The entropy has already been added above, so this is just for show.
                SetDlgItemInt(hwndDlg, IDC_XVAL, GET_X_LPARAM(lParam), FALSE);
                SetDlgItemInt(hwndDlg, IDC_YVAL, GET_Y_LPARAM(lParam), FALSE);
                unsigned __int64 time = __rdtsc();
                char textBuf[30];
                _i64toa_s(time, textBuf, 30, 10);
                SetDlgItemText(hwndDlg, IDC_TIMER, (LPCSTR)textBuf);
            }
            ReleaseMutex(mouseRandMutex);
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_FREEZE:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    frozen = !frozen;
                    if(frozen)
                    {
                        SetDlgItemText(hwndDlg, IDC_FREEZE, "Unfreeze");
                    }
                    else
                    {
                        SetDlgItemText(hwndDlg, IDC_FREEZE, "Freeze");
                    }
                }
                break;
            }
    }

    return FALSE;
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    hDialog = NULL;
    hInst = hInstance;
    frozen = false;
    pool = new unsigned char[POOL_SIZE];
    mouseRandMutex = CreateMutex(NULL, FALSE, NULL);
    NESSIEinit(&newEntropy);
    HANDLE hBgThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&Mixer, NULL, 0, NULL);
    INT_PTR res = DialogBox(hInstance, MAKEINTRESOURCE(DLG_MAIN), NULL, (DLGPROC)DialogProc);
    TerminateThread(hBgThread, 0);
    CloseHandle(mouseRandMutex);
    delete[] pool;
    return res;
}


